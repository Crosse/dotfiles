# vim: set ft=sh:
########################################################################
#
# ~/.rc/prompt
#
# This file is sourced from .rc/rc.
#
# All configuration to setup the shell prompt ($PS1, etc.) should go
# in here.
########################################################################

RC_FILENAME=".rc/prompt"
rc_log "starting up"

# None of this matters if the shell isn't interactive.
[[ "${-}" != *i* ]] && return

# This uses 'which' instead of 'command' on the off-chance that git is
# an alias to, say, Github's 'hub' command and 'command' just does the
# wrong thing.
if [ -x "$(which git 2>/dev/null)" ]; then
    # If the "git" command exists on this system, define a function that
    # can be used in the $PS1 prompt to show the user relevant
    # information about a git repository, if the user is currently in
    # one.
    function parse_git_status {
        # Sometimes git repositories are large, and calculating
        # this information takes too long.  In that case, the user can
        # define $NOPATHBRANCHES, which will stop this function from
        # parsing the git repo.
        if [ -z "$NOPATHBRANCHES" ]; then
            typeset branch=$(git rev-parse --abbrev-ref HEAD 2> /dev/null)
            [[ -z $branch ]] && return

            typeset status=$(git status 2> /dev/null)
            typeset result=$branch

            [[ "$status" = *deleted:* ]] && result=${result}-
            [[ "$status" = *modified:* ]] && result=${result}*
            [[ "$status" = *Untracked\ files:* ]] && result=${result}+
            printf "[$result] "
        fi
    }
    GITPARSING=1
fi

[[ -z "$SCREEN_COLORS" ]] && SCREEN_COLORS=$(tput colors)
if [ $SCREEN_COLORS -eq 0 ]; then
    # Build a "dumb" prompt that should work everywhere.
    [[ -n "$GITPARSING" ]] && g='$(parse_git_status)'
    export PS1="\n\u@\h\$($g) \w\n\$ "
else
    # Force 256-color in tmux if the "real" terminal supports 256
    # colors.
    if [ "$TERM" == "screen" -a "$SCREEN_COLORS" == 256 ]; then
        TERM=screen-256color
    fi

    bold=$(tput bold 2> /dev/null)
    dim=$(tput dim 2> /dev/null)
    reset=$(tput sgr0)
    black=$(tput setaf 0 0 0 2> /dev/null)

    if [ $? -eq 0 ]; then
        red=$(tput setaf 1 1 1 )
        green=$(tput setaf 2 2 2)
        yellow=$(tput setaf 3 3 3)
        blue=$(tput setaf 4 4 4)
        magenta=$(tput setaf 5 5 5)
        cyan=$(tput setaf 6 6 6)
        white=$(tput setaf 7 7 7)
    else
        black=$(tput setaf 0)
        red=$(tput setaf 1)
        green=$(tput setaf 2)
        yellow=$(tput setaf 3)
        blue=$(tput setaf 4)
        magenta=$(tput setaf 5)
        cyan=$(tput setaf 6)
        white=$(tput setaf 7)
    fi

    # Change the prompt color depending on whether the real UID is root
    # or a regular user.
    if [ $(id -ru) == '0' ] ; then
        HOSTCOLOR="\[$red\]"
    else
        HOSTCOLOR="\[$green\]"
    fi

    [[ -n "$GITPARSING" ]] && g="\[${reset}${yellow}\]\$(parse_git_status)\[${reset}\]"
    [[ -n "$SSH_CLIENT" ]] && host="\[${dim}${white}\]@\[${reset}${green}\]\h\[${reset}\]"

    # Set the title of an xterm.
    case $TERM in
        xterm*|rxvt*|screen*)
            TERMTITLE="\[\e]0;\u@\h: \w\a\]"
            ;;
    esac

    # Build a colorized prompt.
    PS1="\n${TERMTITLE}"                                # Set the xterm title.
    PS1="${PS1}${HOSTCOLOR}\u"                          # Username
    PS1="${PS1}$host"                                   # Add the host, if not local
    PS1="${PS1} "
    PS1="${PS1}$g"                                      # git status, if available
    PS1="${PS1}\[${cyan}\]\w\[${reset}\]"               # working directory
    PS1="${PS1}\n"                                      # new line.
    PS1="${PS1}\[${dim}${white}\]\$\[${reset}\] "       # Either '$' or '#'
    export PS1

    PS2="\[${yellow}\]> \[${reset}\]"
    export PS2
fi

unset GITPARSING HOSTCOLOR g b host TERMTITLE
unset bold dim reset black red green yellow blue magenta cyan white

rc_log "done."
