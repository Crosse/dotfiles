#!/usr/bin/env python3
import platform
import re
import shutil
import subprocess
import sys
from typing import Optional

# Ensure UTF-8 output for Nerd Font icons
try:
    sys.stdout.reconfigure(encoding="utf-8")  # Python 3.7+
except Exception:
    pass


def timedelta_fmt(seconds: float) -> str:
    seconds = int(round(seconds))
    m, s = divmod(seconds, 60)
    h, m = divmod(m, 60)
    d, h = divmod(h, 24)
    if d > 0:
        return f"{d}d {h}h"
    if h > 0:
        return f"{h}h {m}m"
    if m > 0:
        return f"{m} mins"
    return f"{s} secs"


def get_battery_icon(pct: int, state: str, adapter_attached: bool = False) -> int:
    """
    Return the Nerd Font codepoint for a unified battery icon that represents both battery and adapter status.
    States used: 'unknown', 'charging', 'discharging', 'fully_charged', 'pending_charge', 'pending_discharge'
    """
    state = (state or "unknown").lower().replace("-", "_")

    # If adapter is attached, use charging-related icons
    if adapter_attached:
        if state == "fully_charged":
            # Fully charged with adapter: use plug icon
            return 0xFBA3
        else:
            # Charging with adapter: use charging battery icons
            icon = 0xF584
            if pct < 40:
                ofs = int(round(pct / 10.0))
                icon += ofs
            elif pct < 60:
                icon = 0xF587
            elif pct < 80:
                icon = 0xF588
            elif pct < 90:
                icon = 0xF589
            else:
                icon = 0xF58A
            return icon
    else:
        # Discharging: use battery icons
        icon = 0xF578
        ofs = int(round(pct / 10.0))
        if ofs < 10:
            icon += ofs
        return icon


def _parse_pmset_time(time_str: str) -> Optional[float]:
    """
    Parse time strings from pmset output (e.g., "2:30" or "1:15") and return seconds.
    Returns None if parsing fails.
    """
    time_str = time_str.strip()
    m = re.search(r"(\d+):(\d+)", time_str)
    if m:
        hours = int(m.group(1))
        minutes = int(m.group(2))
        return (hours * 3600) + (minutes * 60)
    return None


def batt_darwin() -> None:
    try:
        out = subprocess.check_output(["pmset", "-g", "ps"], text=True)
    except Exception:
        print("Unknown!")
        sys.exit(1)

    adapter_attached = "Now drawing from 'AC Power'" in out
    batt_line = next((ln for ln in out.splitlines() if "InternalBattery" in ln), None)

    if not batt_line:
        # No battery found, just show adapter status
        adapter_icon = 0xFBA3 if adapter_attached else 0xFBA4
        print(chr(adapter_icon))
        return

    m_pct = re.search(r"(\d+)%", batt_line)
    pct = int(m_pct.group(1)) if m_pct else 0

    lower = batt_line.lower()
    # Determine state heuristically from the line content
    if "not charging" in lower:
        state = "pending_charge"
    elif "charged" in lower and "charging" not in lower:
        state = "fully_charged"
    elif "discharging" in lower:
        state = "discharging"
    elif "charging" in lower:
        state = "charging"
    else:
        state = "unknown"

    # Try to extract time estimate from pmset output
    time_str = None
    time_seconds = None
    
    # Look for "Time remaining" (discharging) or "Time until charged" (charging)
    for line in out.splitlines():
        line_lower = line.lower()
        if "time remaining" in line_lower:
            # Extract time value from line like "Time remaining: 2:30"
            m = re.search(r"time remaining:\s*(.+?)(?:\s|$)", line, re.IGNORECASE)
            if m:
                time_seconds = _parse_pmset_time(m.group(1))
                break
        elif "time until charged" in line_lower:
            # Extract time value from line like "Time until charged: 1:15"
            m = re.search(r"time until charged:\s*(.+?)(?:\s|$)", line, re.IGNORECASE)
            if m:
                time_seconds = _parse_pmset_time(m.group(1))
                break

    icon = get_battery_icon(pct, state, adapter_attached)
    
    if time_seconds is not None:
        time_str = timedelta_fmt(time_seconds)
        print(f"{chr(icon)} ({time_str})")
    else:
        print(f"{chr(icon)} ({pct}%)")


def _find_upower_battery() -> Optional[str]:
    if not shutil.which("upower"):
        return None
    try:
        devices = subprocess.check_output(["upower", "-e"], text=True).splitlines()
    except Exception:
        return None
    # Prefer devices that look like batteries
    for dev in devices:
        if "battery" in dev.lower() or "BAT" in dev:
            return dev.strip()
    return None


def _parse_upower_info(dev: str) -> dict:
    info = {
        "percentage": None,
        "state": "unknown",
        "time_to_empty_hours": None,
        "time_to_full_hours": None,
        "energy_rate_w": None,
    }
    try:
        text = subprocess.check_output(["upower", "-i", dev], text=True)
    except Exception:
        return info

    # Simple key-value parsing
    for line in text.splitlines():
        ln = line.strip().lower()
        if ln.startswith("percentage:"):
            m = re.search(r"(\d+)%", ln)
            if m:
                info["percentage"] = int(m.group(1))
        elif ln.startswith("state:"):
            st = ln.split(":", 1)[1].strip()
            st = st.replace("-", "_")
            if st == "fully_charged":
                info["state"] = "fully_charged"
            elif st in ("charging", "discharging", "pending_charge", "pending_discharge", "unknown"):
                info["state"] = st
            else:
                info["state"] = "unknown"
        elif ln.startswith("time to empty:"):
            m = re.search(r"([0-9.]+)\s*hours", ln)
            if m:
                info["time_to_empty_hours"] = float(m.group(1))
        elif ln.startswith("time to full:"):
            m = re.search(r"([0-9.]+)\s*hours", ln)
            if m:
                info["time_to_full_hours"] = float(m.group(1))
        elif ln.startswith("energy-rate:"):
            m = re.search(r"([0-9.]+)\s*w", ln)
            if m:
                info["energy_rate_w"] = float(m.group(1))
    return info


def _is_adapter_attached() -> bool:
    """Check if AC adapter is attached on Linux."""
    try:
        result = subprocess.check_output(["upower", "-e"], text=True)
        return "line-power" in result.lower() and "warning-level" not in result.lower()
    except Exception:
        return False


def batt_linux() -> None:
    dev = _find_upower_battery()
    if not dev:
        # Fallback: show plug icon
        print(chr(0xFBA3))
        return

    info = _parse_upower_info(dev)
    pct = info["percentage"] if info["percentage"] is not None else 0
    state = info["state"]
    adapter_attached = _is_adapter_attached()

    # Try to compute a human-readable time
    time_str = None
    if state == "discharging" and info["time_to_empty_hours"]:
        time_str = timedelta_fmt(info["time_to_empty_hours"] * 3600.0)
    elif state == "charging" and info["time_to_full_hours"]:
        time_str = timedelta_fmt(info["time_to_full_hours"] * 3600.0)

    icon = get_battery_icon(pct, state, adapter_attached)
    if time_str:
        print(f"{chr(icon)} ({time_str})")
    elif info["energy_rate_w"] is not None:
        print(f"{chr(icon)} ({info['energy_rate_w']:.1f}W)")
    else:
        print(f"{chr(icon)} ({pct}%)")


def main() -> None:
    system = platform.system()
    if system == "Linux":
        batt_linux()
    elif system == "Darwin":
        batt_darwin()
    else:
        print("Unknown!")
        sys.exit(1)


if __name__ == "__main__":
    main()
